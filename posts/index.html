<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content><meta name=description content="Posts - Q-song | 技术.生活.阅读.思考"><meta name=author content="Mumu"><link rel=canonical href=https://mugong-song.github.io/blog/posts/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://mugong-song.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mugong-song.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mugong-song.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://mugong-song.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://mugong-song.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://mugong-song.github.io/blog/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://mugong-song.github.io/blog/posts/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Posts"><meta property="og:description" content="个人博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mugong-song.github.io/blog/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mugong-song.github.io/blog/ accesskey=h title="Q-song (Alt + H)"><img src=https://mugong-song.github.io/blog/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mugong-song.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://mugong-song.github.io/blog/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://mugong-song.github.io/blog/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://mugong-song.github.io/blog/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://mugong-song.github.io/blog/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>slice 和 数组</h2></header><div class=entry-content><p>Go 语言里 slice 和 map 是非常有用的两个内置数据结构， 线上的工程代码几乎不可能绕开它们。
1.数组与切片 因为切片（slice）比数组更好用，也更安全，Go 推荐使用 slice 而不是数组。本节内容比较 了 slice 和数组的区别，也研究了 slice 的一些特有的性质。
1.1数组和切片有何异同 Go 语言中的切片（slice）结构的本质是对数组的封装，它描述一个数组的片段。无论是数组 还是切片，都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更改。在 Go 语言中，数组是不常见的，因为其长度 是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。而切片则非常灵 活，它可以动态地扩容，且切片的类型和长度无关。
func main() { arr1 := [1]int{1} arr2 := [2]int{1, 2} if arr1 == arr2 { fmt.Println("equal type") } } 尝试运行，报编译错误：
./test.go:16:10: invalid operation: arr1 == arr2 (mismatched types [1]int and [2]int) 因为两个数组的长度不同，根本就不是同一类型，因此不能进行比较。 数组是一片连续的内存，切片实际上是一个结构体，包含三个字段：长度、容量、底层数组。
// src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 注意，底层数组可以被多个切片同时指向，因此对一个切 片的元素进行操作有可能会影响到其他切片。
...</p></div><footer class=entry-footer><span title='2025-10-20 00:00:00 +0000 UTC'>2025年10月20日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to slice 和 数组" href=https://mugong-song.github.io/blog/posts/slice_01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL_Index 索引</h2></header><div class=entry-content><p>在 Go 后端开发中，我们通常使用 MySQL 或 PostgreSQL 等关系型数据库，索引设计的好坏直接决定了服务接口的响应速度。
1.索引设计 1.1 选择合适的列作为索引： 选择性高（High Selectivity）： 索引列的不重复值越多越好。例如，用户 ID（唯一）比性别（只有两三种值）更适合作为索引。 场景： 在设计用户服务时，user_id、email 等是理想的索引列。 常用作查询条件（Where）： 经常出现在 WHERE 子句中的列，或者用于连接（JOIN）的列。 排序/分组（Order By/Group By）： 经常用于排序或分组的列。 1.2 考虑联合索引（Composite Index）： 最左前缀原则 (Leftmost Prefix Principle)： 这是联合索引设计的核心。如果创建了 (A, B, C) 的联合索引，它可以用于查询 WHERE A = ?、WHERE A = ? AND B = ?、WHERE A = ? AND B = ? AND C = ?，但不能单独用于 WHERE B = ? 或 WHERE C = ?。 场景： 在设计订单查询接口时，如果经常查询 WHERE user_id = ? AND order_status = ?，应建立 (user_id, order_status) 的联合索引。 1.3 覆盖索引 (Covering Index)： 如果查询的所有字段都包含在索引中，那么数据库不需要回表（查找主键对应的数据行），直接从索引中返回数据即可。这能大幅提升性能。 场景： 当你需要查询某个用户的订单状态和创建时间，只创建 (user_id, status, create_time) 的联合索引。查询语句为 SELECT status, create_time FROM orders WHERE user_id = ?，数据库直接通过索引就能拿到结果。 1.4 索引数量的平衡： 索引不是越多越好。每个索引都会占用磁盘空间，并且在进行 INSERT, UPDATE, DELETE 操作时，数据库需要维护索引，造成写操作性能下降。 场景： 在设计高写入量的日志表或消息表时，应尽量少建索引，只保留用于最核心查询的索引。 2.高效命中策略 使用 Explain ： 在 Go 后端进行复杂查询优化时，一定要在测试环境使用 EXPLAIN 命令分析 SQL 语句，确保 type 列不是 ALL（全表扫描），key 列使用了正确的索引。
...</p></div><footer class=entry-footer><span title='2025-10-20 00:00:00 +0000 UTC'>2025年10月20日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to SQL_Index 索引" href=https://mugong-song.github.io/blog/posts/sql_index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go sheduler 是什么?</h2></header><div class=entry-content><p>Go sheduler是什么? Go 程序的执行有两个层面：Go Program 和 Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutine 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。
Go scheduler 可以说是 Go 运行时的一个最重要的 部分了。 Runtime 维护所有的 goroutine ，并通过 scheduler 来进行调度。goroutine 和 threads 是独立的， 但是 goroutine 要依赖 threads 才能执行。 Go 程序执行的高效和 scheduler 的调度是分不开的。 实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutine 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面，操作系统并不能感知到 goroutine 的存在。
G、M、P三个基础的结构体来实现 goroutine 的调度： G 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。 M 表示内核线程，包含正在运行的 goroutine 等字段。 P 代表一个虚拟的CPU Processor，它维护一个处于 Runnable 状态的 goroutine 队列，M 需要获得 P 才能运行 G。 当然还有一个核心的结构体：sched，它总揽全局，维持整个调度器的运行。 Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一 个 M 用来开始 G 的运行。随着时间的推移，G和M的创建数量逐渐增多。 在 Go 的早期版本，并没有 P 这个结构体，M 必须从一个全局的队列里获取要运行的 G，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来调度器在 Dmitry Vyukov (Go 语言运行时 runtime 和调度器的核心贡献者之一) ，加 上了 P 结构体。每个 P 维护一个处于 Runnable 状态的 G 的队列，解决了原来的全局锁问题。
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Go sheduler 是什么?" href=https://mugong-song.github.io/blog/posts/gmp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka的rebalance?什么情况下会出现?</h2></header><div class=entry-content><p>Kafka 的 Rebalance (重平衡) 是 Consumer Group (消费者组) 中的一个核心机制，它用于在 Consumer Group 内部重新分配 Topic 的分区（Partition）所有权。 Rebalance 确保了在集群运行过程中，Consumer Group 里的所有消费者能均匀、独占地消费所有相关的分区。
1.什么是 Rebalance (重平衡)？ 在 Kafka 中，一个 Consumer Group 消费一个或多个 Topic。每个分区在同一时刻只能被 Consumer Group 内的一个 Consumer 实例消费。 Rebalance 就是 Consumer Group 内部达成一致，确定“谁”来消费“哪个”分区的过程。 1.1 核心目标 负载均衡：将分区均匀地分配给组内所有健康的 Consumer 实例。 高可用性：当有 Consumer 实例失败或退出时，Rebalance 机制会将它之前负责的分区重新分配给组内其他Consumer，确保消费不会中断。 1.2 Rebalance 的过程 整个过程由 Consumer Group 的 Coordinator（协调器，通常是某个 Broker） 负责协调：
-Join Group (加入组)：新的 Consumer 加入或旧的 Consumer 重新连接时，会向 Coordinator 发送请求。 -Sync Group (同步组)：Coordinator 在收到所有 Consumer 的 Join 请求后，会选出一个 Leader Consumer。 -分配方案：Leader Consumer 负责制定分区到 Consumer 的映射关系（分配策略）。 -执行分配：Coordinator 将分配方案通知给所有 Consumer，各个 Consumer 按照方案开始消费新分配的分区。 2.什么情况下会出现 Rebalance？ 任何导致 Consumer Group 内部成员发生变化或分区信息发生变化的操作，都会触发 Rebalance。
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Kafka的rebalance?什么情况下会出现?" href=https://mugong-song.github.io/blog/posts/kafka_rebalance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Type Assertion 类型断言</h2></header><div class=entry-content><p>在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。
一、基本语法 value, ok := interfaceVar.(ConcreteType)
interfaceVar：一个接口类型的变量 ConcreteType：你期望它实际存储的具体类型（如 int, string, MyStruct 等） value：如果断言成功，就是该类型的值 ok：布尔值，表示断言是否成功
二、为什么需要类型断言？ Go 的接口（interface）可以存储任何类型的值，但当你想使用这个值的具体方法或字段时，就必须知道它的真实类型。
var i interface{} = “hello”
// 我知道它是 string，但接口本身不能直接调用 len() s := i.(string) // 类型断言：断言 i 是 string fmt.Println(len(s)) // 现在可以了
三、两种写法 安全断言（推荐） —— 带 ok 判断 s, ok := i.(string) if ok { fmt.Println("字符串长度:", len(s)) } else { fmt.Println("i 不是一个字符串") } 优点：不会 panic，适合不确定类型时使用。 直接断言 —— 不检查 ok s := i.(string) // 如果 i 不是 string，会 panic！ 面临的风险：如果类型不匹配，程序会崩溃（panic）。 仅在你100%确定类型时使用。
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Type Assertion 类型断言" href=https://mugong-song.github.io/blog/posts/type_assertion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>了解分布式锁吗?</h2></header><div class=entry-content><p>分布式锁是分布式系统从“松散运行”走向“协作、可靠运行”的关键桥梁。
1.什么是分布式锁? 分布式锁是用于在分布式系统中协调多个进程或线程访问共享资源的一种机制，确保在任何时刻只有一个客户端能够操作特定的资源，从而保证数据的一致性。 2.分布式锁的基本要素 无论是基于 Redis、ZooKeeper 还是数据库实现，一个可靠的分布式锁必须满足三个要素： *加锁（Lock）：在资源上设置一个锁的标记。 *设置过期时间（TTL）：防止客户端宕机导致锁无法释放，造成死锁。这是分布式锁与本地锁（如 Java 的 ReentrantLock）最核心的区别。 *释放锁（Unlock）：客户端完成操作后，安全地移除锁。 3.分布式锁面临问题和解决 3.1 死锁 如果客户端在获取锁后，由于某种原因（例如，程序崩溃）未能正常释放锁，导致锁一直被占用，其他客户端无法获取锁，造成死锁。解决方案：在加锁的同时设置过期时间，即使客户端未能正常释放锁，锁也会在过期后自动释放。或者使用 Redlock 算法，提高锁的可靠性，防止死锁。 3.2 锁的误删 -如果客户端 A 获取锁后，由于执行时间过长，导致锁过期自动释放。此时，客户端 B 获取了锁。然后，客户端 A 执行完业务逻辑后，尝试释放锁，但实际上释放的是客户端 B 的锁，造成锁的误删除。解决方案：在加锁时，将锁的值设置为一个唯一标识（例如，UUID），在释放锁时，先判断锁的值是否与自己的唯一标识相等，如果相等，则释放锁；否则，不释放锁。此过程要保证原子性，可以使用 Lua 脚本实现。 -在网络分区的情况下，可能会导致多个进程同时认为自己持有锁。解决方案：在获取锁时生成一个唯一的 UUID，并将其存储在锁的 Key 中。在释放锁时，先检查当前存储的 UUID 是否与自己的 UUID 匹配，只有匹配时才释放锁。 3.3 锁的续期 如果客户端在加锁后，执行时间超过了锁的过期时间，导致锁被自动释放。此时，其他客户端可能会获取锁，造成并发问题。解决方案：客户端在获取锁后，启动一个后台线程，定期检查锁的剩余时间，如果剩余时间小于一定阈值，则使用 EXPIRE 命令续期锁的过期时间。此流程可以自己实现，也可以使用开源框架，例如Redisson 框架不仅提供了自动续期的功能，还可以简化分布式锁的实现。 3.4 锁的竞争 在高并发场景下，多个进程可能会同时竞争锁，导致锁的获取失败率较高。解决方案：可以使用随机退避重试策略，在获取锁失败后，随机等待一段时间后再次重试。 3.5 锁的重入性 如果同一个进程多次尝试获取锁，可能会导致锁的获取失败。解决方案：在锁的 Key 中存储一个计数器，表示当前进程获取锁的次数。每次获取锁时增加计数器，释放锁时减少计数器，只有计数器为 0 时才删除锁的 Key。 3.6 锁的公平性 多个进程同时请求锁时，可能会出现“饥饿”现象，某些进程长时间无法获取锁。解决方案：可以使用 Redis 的 List 数据结构实现排队机制，确保请求锁的进程按照顺序获取锁。或者使用成熟的分布式锁实现库，如 Redisson，它提供了公平锁和可重入锁等功能。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 了解分布式锁吗?" href=https://mugong-song.github.io/blog/posts/distributed_lock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>内存对齐（memory alignment）</h2></header><div class=entry-content><p>看起来很简单，但它其实是 为了内存对齐而存在的。
type itab struct { inter *interfacetype // 接口类型信息 _type *_type // 实现接口的具体类型信息 hash uint32 // 类型 hash 值 _ [4]byte fun [1]uintptr // 实现接口方法的函数地址 } 一、Go 的结构体内存布局规则 Go 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。
规则大致是： 每个字段的起始地址必须是该字段类型的对齐倍数。 比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。 整个结构体的大小必须是其内部最大对齐单位的整数倍。 编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。
二、itab 的字段分析（以 64 位架构为例） 我们来计算每个字段的内存偏移：
字段 类型 大小 (Size) 自身对齐值 (Align) 偏移量 (Offset)单位:字节 备注 inter *interfacetype 8 字节 8 字节 0 → 8 8 字节对齐 _type *_type 8 字节 8 字节 8→16 8 是 8 的倍数，已对齐 hash uint32 4 字节 4 字节 16→20 16 是 4 的倍数，已对齐 _ [4]byte 4 字节 1 字节 20→24 4 字节的填充 (Padding) fun [1]uintptr 8 字节 8 字节 24→32 8 字节对齐 24 是 8 的倍数 总大小32 字节，结构体最大对齐是 8 字节，总大小 32 是 8 的倍数。
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 内存对齐（memory alignment）" href=https://mugong-song.github.io/blog/posts/memory_alignment/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>你了解内存管理吗?</h2></header><div class=entry-content><p>栈分配和堆分配确实都发生在“对象分配器”的分配阶段， 但它们走的是不同的路径： 栈分配走的是编译期静态分配； 堆分配走的是运行时对象分配器（runtime.mallocgc）。
1.程序启动阶段 Go 运行时启动时（runtime 初始化），会： 向操作系统申请一大块虚拟内存（称为 arena）； 由 页分配器（page allocator） 管理这块内存； 构建堆内存管理结构（mheap、mcentral、mcache）。 这部分只是“预留”内存，真正的对象分配还没发生。
2.用户程序触发分配（对象分配阶段） 当用户代码中创建变量时，比如：
x := MyStruct{} 编译器会在编译阶段决定这个对象是： 分配在栈上（stack allocation） 还是分配在堆上（heap allocation） 这个决策是通过 逃逸分析（Escape Analysis） 完成的。
3.栈分配的过程 如果编译器认为对象只在当前函数作用域内使用，不会被外部引用： 这个对象会直接分配在栈上； 不会调用运行时的内存分配器； 栈内存是随函数调用帧自动增长/释放的； GC 不需要扫描或回收它。 > 关键：栈分配是编译期确定的，性能最好。 4.堆分配的过程 如果对象被闭包引用、返回地址或传递给其他 goroutine，则会发生逃逸： 编译器在生成代码时，会调用运行时的分配器 runtime.mallocgc； mallocgc 会从当前 P 的 mcache 尝试获取一个合适的 span； 若 mcache 缓存不足，就从 mcentral → mheap 逐层申请； 分配完成后，GC 会在堆上追踪这个对象。 >关键：堆分配是运行时动态完成的，涉及 GC 管理。 5.回收阶段 当对象不再被引用时，GC 会标记并清除； 被清除的内存重新回收到 mcache / mcentral / mheap； 长期未使用的页可能由scavenger（拾荒器）归还给 OS。 6.对比栈和堆分配 类型 分配阶段 分配位置 分配速度 是否由 GC 管理 是否逃逸 栈分配 编译期（静态） 每个 goroutine 的调用栈 极快 否 否 堆分配 运行时（动态） 运行时堆（mheap） 慢 是 是</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 你了解内存管理吗?" href=https://mugong-song.github.io/blog/posts/memory_management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何保证 Redis 与数据库的数据一致性?</h2></header><div class=entry-content><p>1.为什么会不一致 ？ Redis 是缓存层，数据库是持久层。 二者数据可能不一致的原因包括： 更新数据库成功，但更新缓存失败； 缓存提前过期； 并发写操作覆盖（顺序问题）； 异步更新延迟。 2.更新策略 策略 描述 优点 缺点 一致性表现 Cache Aside（旁路缓存） 读操作1. 读缓存 2. 如果缓存不存在 ,再读数据库 3. 将数据写入缓存（设置过期时间）写操作: 先更新数据库 ,再删除缓存 常用、简单 删除缓存可能失败；删除顺序不当会不一致 中等 Read/Write Through（读写穿透） 应用不直接访问DB，所有读写都经由缓存代理完成 一致性好 实现复杂，性能略低 较高 Write Behind（异步写回） 只写缓存，由缓存异步刷回数据库 性能高 容易丢数据 差 3.处理并发问题 3.1延迟双删策略（Double Delete） 1. 更新数据库； 2. 删除缓存； 3. 延迟 500ms 再删一次缓存。 //可以应对并发中缓存被“脏写”回的情况。 3.2异步消息队列（MQ） 数据更新时发送 MQ 消息，异步同步缓存状态。
3.3分布式锁 保证更新操作串行执行，避免交叉覆盖。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 如何保证 Redis 与数据库的数据一致性?" href=https://mugong-song.github.io/blog/posts/redis_db_consitent/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>什么是“重锁” Heavy Lock?</h2></header><div class=entry-content><p>1.什么是“重锁”（Heavy Lock） 在 Go 性能调优或并发编程中，我们常说的 “重锁”（heavy lock）不是官方术语，而是一个工程上的概念，指的是：锁竞争严重、临界区较大、持锁时间较长的互斥锁（sync.Mutex）。
1.多个 goroutine 同时频繁地去争夺同一把锁；
2.加锁的代码块中做了比较“重”的操作（比如 I/O、JSON 编码、数据库操作）；
导致 goroutine 阻塞、上下文切换频繁，最终造成性能瓶颈。
2.为什么会出现“重锁”问题 1.临界区太大（锁保护的范围过广）；
2.频繁写操作导致锁争用；
3.使用全局变量或共享状态；
4.没有分片（sharding）或局部化锁机制；
5.锁中包含耗时操作（例如网络请求、磁盘 I/O）。
var mu sync.Mutex var cache = make(map[string]string) func Set(k, v string) { mu.Lock() defer mu.Unlock() cache[k] = v } #当高并发调用 Set() 时，所有 goroutine 都在争抢同一把 mu，这就形成“重锁”。 3.优化思路与替代方案 3.1 使用 sync.Map 适用于读多写少的场景：
var m sync.Map m.Store("a", 1) v, _ := m.Load("a") #sync.Map 内部采用分片和原子操作，避免了全局锁竞争。 3.2 使用原子操作（sync/atomic） 适用于简单的计数、标志位等操作：
var count int64 atomic.AddInt64(&amp;count, 1) #无锁化操作，性能更高，且不阻塞其他 goroutine。 3.3 优化锁粒度（细化锁） 将一把全局锁拆分成多把局部锁：
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 什么是“重锁” Heavy Lock?" href=https://mugong-song.github.io/blog/posts/lock/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://mugong-song.github.io/blog/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://mugong-song.github.io/blog/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>