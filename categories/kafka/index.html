<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kafka | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content><meta name=description content="个人博客"><meta name=author content="Mumu"><link rel=canonical href=https://blog.q-song.top/categories/kafka/><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.q-song.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.q-song.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.q-song.top/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.q-song.top/apple-touch-icon.png><link rel=mask-icon href=https://blog.q-song.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.q-song.top/categories/kafka/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://blog.q-song.top/categories/kafka/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Kafka"><meta property="og:description" content="个人博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kafka"><meta name=twitter:description content="个人博客"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.q-song.top/ accesskey=h title="Q-song (Alt + H)"><img src=https://blog.q-song.top/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.q-song.top/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://blog.q-song.top/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://blog.q-song.top/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://blog.q-song.top/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://blog.q-song.top/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Kafka</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka的rebalance?什么情况下会出现?</h2></header><div class=entry-content><p>Kafka 的 Rebalance (重平衡) 是 Consumer Group (消费者组) 中的一个核心机制，它用于在 Consumer Group 内部重新分配 Topic 的分区（Partition）所有权。 Rebalance 确保了在集群运行过程中，Consumer Group 里的所有消费者能均匀、独占地消费所有相关的分区。
1.什么是 Rebalance (重平衡)？ 在 Kafka 中，一个 Consumer Group 消费一个或多个 Topic。每个分区在同一时刻只能被 Consumer Group 内的一个 Consumer 实例消费。 Rebalance 就是 Consumer Group 内部达成一致，确定“谁”来消费“哪个”分区的过程。 1.1 核心目标 负载均衡：将分区均匀地分配给组内所有健康的 Consumer 实例。 高可用性：当有 Consumer 实例失败或退出时，Rebalance 机制会将它之前负责的分区重新分配给组内其他Consumer，确保消费不会中断。 1.2 Rebalance 的过程 整个过程由 Consumer Group 的 Coordinator（协调器，通常是某个 Broker） 负责协调：
-Join Group (加入组)：新的 Consumer 加入或旧的 Consumer 重新连接时，会向 Coordinator 发送请求。 -Sync Group (同步组)：Coordinator 在收到所有 Consumer 的 Join 请求后，会选出一个 Leader Consumer。 -分配方案：Leader Consumer 负责制定分区到 Consumer 的映射关系（分配策略）。 -执行分配：Coordinator 将分配方案通知给所有 Consumer，各个 Consumer 按照方案开始消费新分配的分区。 2.什么情况下会出现 Rebalance？ 任何导致 Consumer Group 内部成员发生变化或分区信息发生变化的操作，都会触发 Rebalance。
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Kafka的rebalance?什么情况下会出现?" href=https://blog.q-song.top/posts/kafka_rebalance/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Kafka如何实现主从同步?</h2></header><div class=entry-content><p>Kafka 实现主从同步（即 Leader 副本和 Follower 副本之间的数据同步）是其保证数据高可用性和持久性的核心机制。这个过程是**异步拉取（Pull）的，并由 ISR（同步副本集合）机制严格管理。
1.异步拉取 与一些数据库的 Push 模式不同，Kafka 的副本同步采用 Pull 模型：
主动方 (Follower)：Follower 副本是主动方。它会不断地向 Leader 副本发送请求，请求拉取新的消息数据。 拉取单位：Follower 拉取的最小单位是 **日志段（Log Segment）**中的一批消息。 这种拉取模式允许 Follower 控制自己的复制速率。如果 Follower 暂时负载过高，它可以减慢拉取速度，避免被 Leader 的高速写入压垮。 2.关键同步指标 Follower 在同步过程中，会维护和使用两个关键的偏移量（Offset）：
LEO (Log End Offset)：表示该 Follower 已成功写入本地日志的最新消息的下一个 Offset。 HW (High Watermark)：表示所有 ISR 集合中的副本都已经复制并确认写入的最新消息的下一个 Offset。 重要性：HW 之前的消息对 Consumer 是可见且安全的，而 HW 之后的 Leader 消息对 Consumer 是不可见的，以防 Leader 宕机导致数据丢失。 3.ISR (In-Sync Replicas) 机制的保障 同步副本集合（ISR）是衡量同步状态的核心机制：
Leader 维护 ISR：Leader 副本负责维护 ISR 列表。ISR 列表包括 Leader 自身和所有与 Leader 保持“同步”的 Follower 副本。 同步判断标准： -Follower 必须在配置的时间阈值（replica.lag.time.max.ms）内持续向 Leader 发送拉取请求。 -Follower 的 LEO 必须与 Leader 的 LEO 保持在一个可接受的范围内。 副本移出：如果 Follower 无法满足上述条件（如网络延迟过高、宕机），它会被 Leader 移出 ISR。 数据持久性保证：当生产者（Producer）设置为 acks=all 时，Leader 必须等待 ISR 中的所有副本都确认写入了消息，才会返回 ACK 成功。这确保了只要 ISR 中有一个副本存活，数据就不会丢失。 4.主从同步流程简述 Follower 发送 Fetch 请求：Follower 向 Leader 发送 Fetch Request，请求从自己的 LEO 开始的新消息。 Leader 发送消息：Leader 从自己的日志中读取从 Follower LEO 开始的消息，并返回给 Follower。 Follower 写入并更新 LEO：Follower 接收到消息后，将其追加写入到自己的本地日志中，并更新自己的 LEO。 Leader 更新 HW：Leader 收到 Follower 的成功响应后，会检查 所有 ISR 副本的 LEO，并更新 HW 为所有副本 LEO 的最小值。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Kafka如何实现主从同步?" href=https://blog.q-song.top/posts/kafka_sync/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>什么是零拷贝?</h2></header><div class=entry-content><p>零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。
1.核心原理 ？ 在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）： 第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。 第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。 第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。 第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。 零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。
2.常见的零拷贝实现方式 2.1 sendfile 这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。 实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。 消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。 2.2 内存映射文件 (mmap) 内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。 实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。 消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。 3.零拷贝的优势 降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。 减少延迟： 数据传输路径更短。 提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 什么是零拷贝?" href=https://blog.q-song.top/posts/zero_copes/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.q-song.top/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>