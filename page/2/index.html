<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.152.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Q-song | 技术.生活.阅读.思考</title><meta name=description content="个人博客"><meta name=author content="Mumu"><link rel=canonical href=https://mugong-song.github.io/blog/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://mugong-song.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mugong-song.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mugong-song.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://mugong-song.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://mugong-song.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://mugong-song.github.io/blog/index.xml title=rss><link rel=alternate type=application/json href=https://mugong-song.github.io/blog/index.json title=json><link rel=alternate hreflang=zh href=https://mugong-song.github.io/blog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://mugong-song.github.io/blog/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Q-song | 技术.生活.阅读.思考"><meta property="og:description" content="个人博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Q-song | 技术.生活.阅读.思考"><meta name=twitter:description content="个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Q-song | 技术.生活.阅读.思考","url":"https://mugong-song.github.io/blog/","description":"个人博客","logo":"https://mugong-song.github.io/blog/favicon.ico","sameAs":["https://github.com/mugong-song","index.xml","mailto:tomsfamily01@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mugong-song.github.io/blog/ accesskey=h title="Q-song (Alt + H)"><img src=https://mugong-song.github.io/blog/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mugong-song.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://mugong-song.github.io/blog/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://mugong-song.github.io/blog/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://mugong-song.github.io/blog/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://mugong-song.github.io/blog/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>什么是“重锁” Heavy Lock?</h2></header><div class=entry-content><p>1.什么是“重锁”（Heavy Lock） 在 Go 性能调优或并发编程中，我们常说的 “重锁”（heavy lock）不是官方术语，而是一个工程上的概念，指的是：锁竞争严重、临界区较大、持锁时间较长的互斥锁（sync.Mutex）。
1.多个 goroutine 同时频繁地去争夺同一把锁；
2.加锁的代码块中做了比较“重”的操作（比如 I/O、JSON 编码、数据库操作）；
导致 goroutine 阻塞、上下文切换频繁，最终造成性能瓶颈。
2.为什么会出现“重锁”问题 1.临界区太大（锁保护的范围过广）；
2.频繁写操作导致锁争用；
3.使用全局变量或共享状态；
4.没有分片（sharding）或局部化锁机制；
5.锁中包含耗时操作（例如网络请求、磁盘 I/O）。
var mu sync.Mutex var cache = make(map[string]string) func Set(k, v string) { mu.Lock() defer mu.Unlock() cache[k] = v } #当高并发调用 Set() 时，所有 goroutine 都在争抢同一把 mu，这就形成“重锁”。 3.优化思路与替代方案 3.1 使用 sync.Map 适用于读多写少的场景：
var m sync.Map m.Store("a", 1) v, _ := m.Load("a") #sync.Map 内部采用分片和原子操作，避免了全局锁竞争。 3.2 使用原子操作（sync/atomic） 适用于简单的计数、标志位等操作：
var count int64 atomic.AddInt64(&amp;count, 1) #无锁化操作，性能更高，且不阻塞其他 goroutine。 3.3 优化锁粒度（细化锁） 将一把全局锁拆分成多把局部锁：
...</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 什么是“重锁” Heavy Lock?" href=https://mugong-song.github.io/blog/posts/lock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>什么是零拷贝?</h2></header><div class=entry-content><p>零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。
1.核心原理 ？ 在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）： 第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。 第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。 第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。 第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。 零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。
2.常见的零拷贝实现方式 2.1 sendfile 这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。 实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。 消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。 2.2 内存映射文件 (mmap) 内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。 实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。 消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。 3.零拷贝的优势 降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。 减少延迟： 数据传输路径更短。 提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 什么是零拷贝?" href=https://mugong-song.github.io/blog/posts/zero_copes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>主键和唯一键？区别是什么？</h2></header><div class=entry-content><p>主键（Primary Key）是唯一标识每行的非空字段，每表只能有一个； 唯一键（Unique Key）是保证字段值唯一，但允许为NULL，每表可有多个。
主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。
唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。
主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。
用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。
约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。
索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。
简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结
主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。</p></div><footer class=entry-footer><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 主键和唯一键？区别是什么？" href=https://mugong-song.github.io/blog/posts/key/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>First Encounter with Hugo</h2></header><div class=entry-content><p>🚀 什么是 Hugo？ Hugo 是一个基于 Go 语言编写的 静态网站生成器。
它的最大特点是——速度极快、部署方便、几乎零依赖。
使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。
🛠️ 安装 Hugo 在 macOS 上：
brew install hugo</p></div><footer class=entry-footer><span title='2025-10-12 15:30:00 +0800 +0800'>2025年10月12日</span>&nbsp;·&nbsp;<span>Beeta</span></footer><a class=entry-link aria-label="post link to First Encounter with Hugo" href=https://mugong-song.github.io/blog/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>垃圾回收机制 Garbage Collection</h2></header><div class=entry-content><p>1.垃圾回收的认识 1.1垃圾回收是什么，有什么作用 GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。 当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请 时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。而 负责垃圾回收的程序组件，即为垃圾回收器。 垃圾回收其实是一个完美的“Simplicity is Complicated”的例子。一方面，程序员受益于 GC，也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。另一 方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。 通常，垃圾回收器的执行过程被划分为两个半独立的组件：
1）赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户 态的代码仅仅只修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上 进行操作。 2）回收器（Collector）：负责执行垃圾回收的代码。
1.2常见的垃圾回收的实现方式有哪些，Go使用的是什么 所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这 两种形式的混合运用。
（1）追踪式 GC 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的 对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。 （2）引用计数式 GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较 多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。 比较常见的 GC 实现方式包括：
1）追踪式，分为多种不同类型，例如： 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内 存上。 2)增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量推进垃圾回收，达到 近似实时、几乎无停顿的效果。 3)增量整理：在增量式的基础上，增加对对象的整理过程。 4)分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于 某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不 长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p></div><footer class=entry-footer><span title='2025-10-12 00:00:00 +0000 UTC'>2025年10月12日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 垃圾回收机制 Garbage Collection" href=https://mugong-song.github.io/blog/posts/garbage-collection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我的第一篇博客</h2></header><div class=entry-content><p>今天开始记录我在 Go 高并发项目中的一些心得体会。</p></div><footer class=entry-footer><span title='2025-10-12 00:00:00 +0000 UTC'>2025年10月12日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 我的第一篇博客" href=https://mugong-song.github.io/blog/posts/fist-blog/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://mugong-song.github.io/blog/>«&nbsp;上一页&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://mugong-song.github.io/blog/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>