<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Lock on Q-song | 技术.生活.阅读.思考</title>
    <link>https://MU-GONG-SONG.github.io/blog/tags/lock/</link>
    <description>Recent content in Lock on Q-song | 技术.生活.阅读.思考</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 14 Oct 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://MU-GONG-SONG.github.io/blog/tags/lock/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>什么是“重锁” Heavy Lock?</title>
      <link>https://MU-GONG-SONG.github.io/blog/posts/lock/</link>
      <pubDate>Tue, 14 Oct 2025 00:00:00 +0000</pubDate>
      <guid>https://MU-GONG-SONG.github.io/blog/posts/lock/</guid>
      <description>&lt;h3 id=&#34;1什么是重锁heavy-lock&#34;&gt;1.什么是“重锁”（Heavy Lock）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Go 性能调优或并发编程中，我们常说的 “重锁”（heavy lock）不是官方术语，而是一个工程上的概念，指的是：锁竞争严重、临界区较大、持锁时间较长的互斥锁（sync.Mutex）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.多个 goroutine 同时频繁地去争夺同一把锁；&lt;/p&gt;
&lt;p&gt;2.加锁的代码块中做了比较“重”的操作（比如 I/O、JSON 编码、数据库操作）；&lt;/p&gt;
&lt;p&gt;导致 goroutine 阻塞、上下文切换频繁，最终造成性能瓶颈。&lt;/p&gt;
&lt;h3 id=&#34;2为什么会出现重锁问题&#34;&gt;2.为什么会出现“重锁”问题&lt;/h3&gt;
&lt;p&gt;1.临界区太大（锁保护的范围过广）；&lt;/p&gt;
&lt;p&gt;2.频繁写操作导致锁争用；&lt;/p&gt;
&lt;p&gt;3.使用全局变量或共享状态；&lt;/p&gt;
&lt;p&gt;4.没有分片（sharding）或局部化锁机制；&lt;/p&gt;
&lt;p&gt;5.锁中包含耗时操作（例如网络请求、磁盘 I/O）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    var mu sync.Mutex
    var cache = make(map[string]string)
    
    func Set(k, v string) {
    mu.Lock()
    defer mu.Unlock()
    cache[k] = v
    }
    #当高并发调用 Set() 时，所有 goroutine 都在争抢同一把 mu，这就形成“重锁”。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3优化思路与替代方案&#34;&gt;3.优化思路与替代方案&lt;/h3&gt;
&lt;h4 id=&#34;31-使用-syncmap&#34;&gt;3.1 使用 sync.Map&lt;/h4&gt;
&lt;p&gt;适用于读多写少的场景：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m sync.Map
m.Store(&amp;quot;a&amp;quot;, 1)
v, _ := m.Load(&amp;quot;a&amp;quot;)
#sync.Map 内部采用分片和原子操作，避免了全局锁竞争。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;32-使用原子操作syncatomic&#34;&gt;3.2 使用原子操作（sync/atomic）&lt;/h4&gt;
&lt;p&gt;适用于简单的计数、标志位等操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var count int64
atomic.AddInt64(&amp;amp;count, 1)
#无锁化操作，性能更高，且不阻塞其他 goroutine。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;33-优化锁粒度细化锁&#34;&gt;3.3 优化锁粒度（细化锁）&lt;/h4&gt;
&lt;p&gt;将一把全局锁拆分成多把局部锁：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
