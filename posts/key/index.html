<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>什么是主键和唯一键？它们的区别是什么？ | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content="Assertion"><meta name=description content="
在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。

主键 (Primary Key)
定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。
作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。
特点
唯一性：所有主键值必须唯一，不可重复。
非空性：主键字段禁止为 NULL。
单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。
索引支持：数据库一般会为主键自动创建索引来提高查询效率。
唯一键 (Unique Key)
定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。
作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。
特点
唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。
多例性：一张表可定义多个唯一键，用来约束不同的业务属性。
索引支持：数据库也通常会为唯一键创建索引，提高检索速度。
主要区别
数量限制
主键：每张表只能有一个。
唯一键：一张表可以定义多个。
用途侧重
主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。
唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。
约束规则
主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。
唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。
索引与性能
主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。
唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。
简单示例
主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。
唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。
总结
主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。

相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。

两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。

其次是主键一定不能为空，而唯一键通常允许空值。

还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。

最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。

总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
"><meta name=author content="Mumu"><link rel=canonical href=https://MU-GONG-SONG.github.io/blog/posts/key/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://MU-GONG-SONG.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://MU-GONG-SONG.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://MU-GONG-SONG.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://MU-GONG-SONG.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://MU-GONG-SONG.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://MU-GONG-SONG.github.io/blog/posts/key/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://MU-GONG-SONG.github.io/blog/posts/key/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="什么是主键和唯一键？它们的区别是什么？"><meta property="og:description" content=" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。
主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。
唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。
主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。
用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。
约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。
索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。
简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结
主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。 "><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-14T00:00:00+00:00"><meta property="article:tag" content="Assertion"><meta name=twitter:card content="summary"><meta name=twitter:title content="什么是主键和唯一键？它们的区别是什么？"><meta name=twitter:description content="
在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。

主键 (Primary Key)
定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。
作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。
特点
唯一性：所有主键值必须唯一，不可重复。
非空性：主键字段禁止为 NULL。
单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。
索引支持：数据库一般会为主键自动创建索引来提高查询效率。
唯一键 (Unique Key)
定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。
作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。
特点
唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。
多例性：一张表可定义多个唯一键，用来约束不同的业务属性。
索引支持：数据库也通常会为唯一键创建索引，提高检索速度。
主要区别
数量限制
主键：每张表只能有一个。
唯一键：一张表可以定义多个。
用途侧重
主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。
唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。
约束规则
主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。
唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。
索引与性能
主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。
唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。
简单示例
主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。
唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。
总结
主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。

相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。

两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。

其次是主键一定不能为空，而唯一键通常允许空值。

还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。

最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。

总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://MU-GONG-SONG.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"什么是主键和唯一键？它们的区别是什么？","item":"https://MU-GONG-SONG.github.io/blog/posts/key/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"什么是主键和唯一键？它们的区别是什么？","name":"什么是主键和唯一键？它们的区别是什么？","description":" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\n主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。\n唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。\n主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。\n用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。\n约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。\n索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。\n简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结\n主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。\n主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。 ","keywords":["Assertion"],"articleBody":" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\n主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。\n唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。\n主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。\n用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。\n约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。\n索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。\n简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结\n主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。\n主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。 ","wordCount":"85","inLanguage":"zh","datePublished":"2025-10-14T00:00:00Z","dateModified":"2025-10-14T00:00:00Z","author":{"@type":"Person","name":"Mumu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://MU-GONG-SONG.github.io/blog/posts/key/"},"publisher":{"@type":"Organization","name":"Q-song | 技术.生活.阅读.思考","logo":{"@type":"ImageObject","url":"https://MU-GONG-SONG.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://MU-GONG-SONG.github.io/blog/ accesskey=h title="Q-song (Alt + H)"><img src=https://MU-GONG-SONG.github.io/blog/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://MU-GONG-SONG.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://MU-GONG-SONG.github.io/blog/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://MU-GONG-SONG.github.io/blog/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://MU-GONG-SONG.github.io/blog/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://MU-GONG-SONG.github.io/blog/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">什么是主键和唯一键？它们的区别是什么？</h1><div class=post-meta><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%bb%e9%94%ae-primary-key aria-label="主键 (Primary Key)">主键 (Primary Key)</a><ul><ul><ul><li><a href=#%e5%ae%9a%e4%b9%89%e7%94%a8%e4%ba%8e%e5%94%af%e4%b8%80%e6%a0%87%e8%af%86%e8%a1%a8%e4%b8%ad%e6%af%8f%e4%b8%80%e8%a1%8c%e6%95%b0%e6%8d%ae%e7%9a%84%e5%ad%97%e6%ae%b5%e6%88%96%e5%ad%97%e6%ae%b5%e7%bb%84%e5%90%88%e6%98%af%e8%a1%a8%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a0%87%e8%af%86 aria-label=定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。>定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。</a></li><li><a href=#%e4%bd%9c%e7%94%a8%e4%b8%ba%e5%85%b6%e4%bb%96%e8%a1%a8%e6%8f%90%e4%be%9b%e5%85%b3%e8%81%94%e5%bc%95%e7%94%a8%e7%9a%84%e6%a0%b8%e5%bf%83%e5%ad%97%e6%ae%b5%e5%94%af%e4%b8%80%e6%a0%87%e8%af%86%e8%a1%a8%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e8%a1%8c%e6%95%b0%e6%8d%ae aria-label=作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。>作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。</a></li><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li></ul></ul></ul></li><li><a href=#%e5%94%af%e4%b8%80%e9%94%ae-unique-key aria-label="唯一键 (Unique Key)">唯一键 (Unique Key)</a><ul><ul><ul><li><a href=#%e5%ae%9a%e4%b9%89%e7%94%a8%e4%ba%8e%e7%a1%ae%e4%bf%9d%e5%ad%97%e6%ae%b5%e6%88%96%e5%ad%97%e6%ae%b5%e7%bb%84%e5%90%88%e7%9a%84%e5%80%bc%e5%94%af%e4%b8%80%e4%bd%86%e9%9d%9e%e8%a1%a8%e7%9a%84%e5%94%af%e4%b8%80%e6%a0%87%e8%af%86 aria-label=定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。>定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。</a></li><li><a href=#%e4%bd%9c%e7%94%a8%e6%8f%90%e4%be%9b%e8%be%85%e5%8a%a9%e7%9a%84%e5%94%af%e4%b8%80%e6%80%a7%e7%ba%a6%e6%9d%9f%e4%be%bf%e4%ba%8e%e4%b8%9a%e5%8a%a1%e9%80%bb%e8%be%91%e4%bd%bf%e7%94%a8%e7%a1%ae%e4%bf%9d%e6%8c%87%e5%ae%9a%e5%88%97%e6%88%96%e5%88%97%e7%bb%84%e5%90%88%e5%9c%a8%e8%a1%a8%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%94%af%e4%b8%80%e9%98%b2%e6%ad%a2%e9%87%8d%e5%a4%8d%e6%95%b0%e6%8d%ae%e4%ba%a7%e7%94%9f aria-label=作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。>作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。</a></li><li><a href=#%e7%89%b9%e7%82%b9-1 aria-label=特点>特点</a></li></ul></ul></ul></li><li><a href=#%e4%b8%bb%e8%a6%81%e5%8c%ba%e5%88%ab aria-label=主要区别>主要区别</a><ul><ul><ul><li><a href=#%e6%95%b0%e9%87%8f%e9%99%90%e5%88%b6 aria-label=数量限制>数量限制</a></li><li><a href=#%e7%94%a8%e9%80%94%e4%be%a7%e9%87%8d aria-label=用途侧重>用途侧重</a></li><li><a href=#%e7%ba%a6%e6%9d%9f%e8%a7%84%e5%88%99 aria-label=约束规则>约束规则</a></li><li><a href=#%e7%b4%a2%e5%bc%95%e4%b8%8e%e6%80%a7%e8%83%bd aria-label=索引与性能>索引与性能</a></li></ul></ul></ul></li><li><a href=#%e7%ae%80%e5%8d%95%e7%a4%ba%e4%be%8b aria-label=简单示例>简单示例</a></li></ul></div></details></div><div class=post-content><blockquote><p>在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。</p></blockquote><h2 id=主键-primary-key>主键 (Primary Key)<a hidden class=anchor aria-hidden=true href=#主键-primary-key>#</a></h2><h5 id=定义用于唯一标识表中每一行数据的字段或字段组合是表的核心标识>定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。<a hidden class=anchor aria-hidden=true href=#定义用于唯一标识表中每一行数据的字段或字段组合是表的核心标识>#</a></h5><h5 id=作用为其他表提供关联引用的核心字段唯一标识表中的每一行数据>作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。<a hidden class=anchor aria-hidden=true href=#作用为其他表提供关联引用的核心字段唯一标识表中的每一行数据>#</a></h5><h5 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h5><p>唯一性：所有主键值必须唯一，不可重复。
非空性：主键字段禁止为 NULL。
单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。
索引支持：数据库一般会为主键自动创建索引来提高查询效率。</p><h2 id=唯一键-unique-key>唯一键 (Unique Key)<a hidden class=anchor aria-hidden=true href=#唯一键-unique-key>#</a></h2><h5 id=定义用于确保字段或字段组合的值唯一但非表的唯一标识>定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。<a hidden class=anchor aria-hidden=true href=#定义用于确保字段或字段组合的值唯一但非表的唯一标识>#</a></h5><h5 id=作用提供辅助的唯一性约束便于业务逻辑使用确保指定列或列组合在表中的数据唯一防止重复数据产生>作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。<a hidden class=anchor aria-hidden=true href=#作用提供辅助的唯一性约束便于业务逻辑使用确保指定列或列组合在表中的数据唯一防止重复数据产生>#</a></h5><h5 id=特点-1>特点<a hidden class=anchor aria-hidden=true href=#特点-1>#</a></h5><p>唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。
多例性：一张表可定义多个唯一键，用来约束不同的业务属性。
索引支持：数据库也通常会为唯一键创建索引，提高检索速度。</p><h2 id=主要区别>主要区别<a hidden class=anchor aria-hidden=true href=#主要区别>#</a></h2><h5 id=数量限制>数量限制<a hidden class=anchor aria-hidden=true href=#数量限制>#</a></h5><p>主键：每张表只能有一个。
唯一键：一张表可以定义多个。</p><h5 id=用途侧重>用途侧重<a hidden class=anchor aria-hidden=true href=#用途侧重>#</a></h5><p>主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。
唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。</p><h5 id=约束规则>约束规则<a hidden class=anchor aria-hidden=true href=#约束规则>#</a></h5><p>主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。
唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。</p><h5 id=索引与性能>索引与性能<a hidden class=anchor aria-hidden=true href=#索引与性能>#</a></h5><p>主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。
唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。</p><h2 id=简单示例>简单示例<a hidden class=anchor aria-hidden=true href=#简单示例>#</a></h2><p>主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。
唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。
总结</p><p>主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。</p><pre tabindex=0><code>主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。

相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。

两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。

其次是主键一定不能为空，而唯一键通常允许空值。

还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。

最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。

总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://MU-GONG-SONG.github.io/blog/tags/assertion/>Assertion</a></li></ul><nav class=paginav><a class=prev href=https://MU-GONG-SONG.github.io/blog/posts/memory_alignment/><span class=title>« 上一页</span><br><span>内存对齐（memory alignment）</span>
</a><a class=next href=https://MU-GONG-SONG.github.io/blog/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/><span class=title>下一页 »</span><br><span>初识 Hugo：打造你的静态博客</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://MU-GONG-SONG.github.io/blog/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>