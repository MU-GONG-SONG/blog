[{"content":" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\n一、基本语法 value, ok := interfaceVar.(ConcreteType)\ninterfaceVar：一个接口类型的变量 ConcreteType：你期望它实际存储的具体类型（如 int, string, MyStruct 等） value：如果断言成功，就是该类型的值 ok：布尔值，表示断言是否成功\n二、为什么需要类型断言？ Go 的接口（interface）可以存储任何类型的值，但当你想使用这个值的具体方法或字段时，就必须知道它的真实类型。\nvar i interface{} = \u0026ldquo;hello\u0026rdquo;\n// 我知道它是 string，但接口本身不能直接调用 len() s := i.(string) // 类型断言：断言 i 是 string fmt.Println(len(s)) // 现在可以了\n三、两种写法 安全断言（推荐） —— 带 ok 判断 s, ok := i.(string) if ok { fmt.Println(\u0026#34;字符串长度:\u0026#34;, len(s)) } else { fmt.Println(\u0026#34;i 不是一个字符串\u0026#34;) } ✅ 优点：不会 panic，适合不确定类型时使用。\n直接断言 —— 不检查 ok s := i.(string) // 如果 i 不是 string，会 panic！ ⚠️ 风险：如果类型不匹配，程序会崩溃（panic）。\n仅在你100%确定类型时使用。\n四、典型使用场景 场景1：从 interface{} 中取值（比如 JSON 解析）\ndata := map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25, } name, _ := data[\u0026#34;name\u0026#34;].(string) age, _ := data[\u0026#34;age\u0026#34;].(int) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) json.Unmarshal 默认把对象解析成 map[string]interface{}，就需要类型断言。\n场景2：处理不同类型的事件\ntype Event interface{} type ClickEvent struct{ X, Y int } type KeyEvent struct{ Key string } func HandleEvent(e Event) { switch v := e.(type) { case ClickEvent: fmt.Printf(\u0026#34;点击事件: (%d, %d)\\n\u0026#34;, v.X, v.Y) case KeyEvent: fmt.Printf(\u0026#34;按键事件: %s\\n\u0026#34;, v.Key) default: fmt.Println(\u0026#34;未知事件\u0026#34;) } } 这里用了 类型选择（type switch），是类型断言的高级形式。\n五、常见错误 错误1：断言失败导致 panic\nvar i interface{} = 42 s := i.(string) // panic: interface is int, not string ✅ 正确做法：\ns, ok := i.(string) if !ok { fmt.Println(\u0026#34;不是字符串\u0026#34;) } 错误2：对 nil 接口断言\nvar i interface{} // nil s, ok := i.(string) // ok == false 即使底层类型是 string，但值是 nil，断言也会失败。\n","permalink":"https://MU-GONG-SONG.github.io/blog/posts/type_assertion/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"一基本语法\"\u003e一、基本语法\u003c/h2\u003e\n\u003cp\u003evalue, ok := interfaceVar.(ConcreteType)\u003c/p\u003e\n\u003cp\u003einterfaceVar：一个接口类型的变量\nConcreteType：你期望它实际存储的具体类型（如 int, string, MyStruct 等）\nvalue：如果断言成功，就是该类型的值\nok：布尔值，表示断言是否成功\u003c/p\u003e\n\u003ch2 id=\"二为什么需要类型断言\"\u003e二、为什么需要类型断言？\u003c/h2\u003e\n\u003cp\u003eGo 的接口（interface）可以存储任何类型的值，但当你想使用这个值的具体方法或字段时，就必须知道它的真实类型。\u003c/p\u003e\n\u003cp\u003evar i interface{} = \u0026ldquo;hello\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e// 我知道它是 string，但接口本身不能直接调用 len()\ns := i.(string)  // 类型断言：断言 i 是 string\nfmt.Println(len(s))  // 现在可以了\u003c/p\u003e\n\u003ch2 id=\"三两种写法\"\u003e三、两种写法\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e安全断言（推荐） —— 带 ok 判断\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\n   s, ok := i.(string)\n   if ok {\n   fmt.Println(\u0026#34;字符串长度:\u0026#34;, len(s))\n   } else {\n   fmt.Println(\u0026#34;i 不是一个字符串\u0026#34;)\n   }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e✅ 优点：不会 panic，适合不确定类型时使用。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e直接断言 —— 不检查 ok\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e   s := i.(string)  // 如果 i 不是 string，会 panic！\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e⚠️ 风险：如果类型不匹配，程序会崩溃（panic）。\u003c/p\u003e","title":"Type Assertion 类型断言"},{"content":" 看起来很简单，但它其实是 为了内存对齐而存在的。\ntype itab struct { inter *interfacetype // 接口类型信息 _type *_type // 实现接口的具体类型信息 hash uint32 // 类型 hash 值 _ [4]byte fun [1]uintptr // 实现接口方法的函数地址 } 一、Go 的结构体内存布局规则 Go 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。\n规则大致是： 每个字段的起始地址必须是该字段类型的对齐倍数。 比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。 整个结构体的大小必须是其内部最大对齐单位的整数倍。 编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。\n二、itab 的字段分析（以 64 位架构为例） 我们来计算每个字段的内存偏移：\n左对齐 居中 右对齐 左 中 右 ","permalink":"https://MU-GONG-SONG.github.io/blog/posts/memory_alignment/","summary":"\u003cblockquote\u003e\n\u003cp\u003e看起来很简单，但它其实是 为了内存对齐而存在的。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etype itab struct {\n    inter *interfacetype // 接口类型信息\n    _type *_type         // 实现接口的具体类型信息\n    hash  uint32         // 类型 hash 值\n    _     [4]byte\n    fun   [1]uintptr     // 实现接口方法的函数地址\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"一go-的结构体内存布局规则\"\u003e一、Go 的结构体内存布局规则\u003c/h2\u003e\n\u003cp\u003eGo 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。\u003c/p\u003e\n\u003cp\u003e规则大致是：\n每个字段的起始地址必须是该字段类型的对齐倍数。\n比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。\n整个结构体的大小必须是其内部最大对齐单位的整数倍。\n编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。\u003c/p\u003e\n\u003cp\u003e二、itab 的字段分析（以 64 位架构为例）\n我们来计算每个字段的内存偏移：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e左对齐\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e居中\u003c/th\u003e\n          \u003cth style=\"text-align: right\"\u003e右对齐\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e左\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e中\u003c/td\u003e\n          \u003ctd style=\"text-align: right\"\u003e右\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"内存对齐（memory alignment）"},{"content":"🚀 什么是 Hugo？ Hugo 是一个基于 Go 语言编写的 静态网站生成器。\n它的最大特点是——速度极快、部署方便、几乎零依赖。\n使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。\n🛠️ 安装 Hugo 在 macOS 上：\nbrew install hugo ","permalink":"https://MU-GONG-SONG.github.io/blog/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","summary":"\u003ch2 id=\"-什么是-hugo\"\u003e🚀 什么是 Hugo？\u003c/h2\u003e\n\u003cp\u003eHugo 是一个基于 Go 语言编写的 \u003cstrong\u003e静态网站生成器\u003c/strong\u003e。\u003cbr\u003e\n它的最大特点是——\u003cstrong\u003e速度极快、部署方便、几乎零依赖\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-安装-hugo\"\u003e🛠️ 安装 Hugo\u003c/h2\u003e\n\u003cp\u003e在 macOS 上：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebrew install hugo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"初识 Hugo：打造你的静态博客"},{"content":" 👋 简介 你好！我是 你的名字，一名热爱技术与写作的创作者。\n这里记录我的学习笔记、项目、随笔与资源分享。\n我热衷于探索高效开发、开源工具和知识体系构建。\n⚡️ 速览 职业：软件工程师 / 前端 / 后端（根据实际修改） 所在地：城市，国家 擅长：Go、Docker、Kubernetes、Hugo 邮箱：you@example.com（请替换） 🧭 详细介绍 我喜欢把复杂的问题拆解成可执行的小步骤——这同样适用于代码和生活。\n我的博客主要分享：实践记录、问题复现与解决方案、工具推荐与配置教程。\n如果你是初学者，欢迎从我的标签页（如 #入门）开始；\n如果你是同行，也欢迎与我交流合作。\n🚀 项目与成果 项目 A — GitHub 链接：简短说明 项目 B — GitHub 链接：简短说明 （你可以在这里列出想展示的作品或文章）\n📫 联系我 📧 邮箱：you@example.com 🐙 GitHub：yourusername 🐦 Twitter：yourhandle 🌅 座右铭 悟已往之不谏，知来者之可追。\n—— 陶渊明《归去来兮辞》\n","permalink":"https://MU-GONG-SONG.github.io/blog/about/","summary":"关于我的简单介绍、联系方式和创作理念。","title":"About — 关于我"},{"content":"今天开始记录我在 Go 高并发项目中的一些心得体会。\n","permalink":"https://MU-GONG-SONG.github.io/blog/posts/fist-blog/","summary":"\u003cp\u003e今天开始记录我在 Go 高并发项目中的一些心得体会。\u003c/p\u003e","title":"我的第一篇博客"}]