[{"content":" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\n一、基本语法 value, ok := interfaceVar.(ConcreteType)\ninterfaceVar：一个接口类型的变量 ConcreteType：你期望它实际存储的具体类型（如 int, string, MyStruct 等） value：如果断言成功，就是该类型的值 ok：布尔值，表示断言是否成功\n二、为什么需要类型断言？ Go 的接口（interface）可以存储任何类型的值，但当你想使用这个值的具体方法或字段时，就必须知道它的真实类型。\nvar i interface{} = \u0026ldquo;hello\u0026rdquo;\n// 我知道它是 string，但接口本身不能直接调用 len() s := i.(string) // 类型断言：断言 i 是 string fmt.Println(len(s)) // 现在可以了\n三、两种写法 安全断言（推荐） —— 带 ok 判断 s, ok := i.(string) if ok { fmt.Println(\u0026#34;字符串长度:\u0026#34;, len(s)) } else { fmt.Println(\u0026#34;i 不是一个字符串\u0026#34;) } ✅ 优点：不会 panic，适合不确定类型时使用。\n直接断言 —— 不检查 ok s := i.(string) // 如果 i 不是 string，会 panic！ ⚠️ 风险：如果类型不匹配，程序会崩溃（panic）。\n仅在你100%确定类型时使用。\n四、典型使用场景 场景1：从 interface{} 中取值（比如 JSON 解析）\ndata := map[string]interface{}{ \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 25, } name, _ := data[\u0026#34;name\u0026#34;].(string) age, _ := data[\u0026#34;age\u0026#34;].(int) fmt.Printf(\u0026#34;姓名: %s, 年龄: %d\\n\u0026#34;, name, age) json.Unmarshal 默认把对象解析成 map[string]interface{}，就需要类型断言。\n场景2：处理不同类型的事件\ntype Event interface{} type ClickEvent struct{ X, Y int } type KeyEvent struct{ Key string } func HandleEvent(e Event) { switch v := e.(type) { case ClickEvent: fmt.Printf(\u0026#34;点击事件: (%d, %d)\\n\u0026#34;, v.X, v.Y) case KeyEvent: fmt.Printf(\u0026#34;按键事件: %s\\n\u0026#34;, v.Key) default: fmt.Println(\u0026#34;未知事件\u0026#34;) } } 这里用了 类型选择（type switch），是类型断言的高级形式。\n五、常见错误 错误1：断言失败导致 panic\nvar i interface{} = 42 s := i.(string) // panic: interface is int, not string ✅ 正确做法：\ns, ok := i.(string) if !ok { fmt.Println(\u0026#34;不是字符串\u0026#34;) } 错误2：对 nil 接口断言\nvar i interface{} // nil s, ok := i.(string) // ok == false 即使底层类型是 string，但值是 nil，断言也会失败。\n","permalink":"https://MU-GONG-SONG.github.io/blog/posts/type_assertion/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"一基本语法\"\u003e一、基本语法\u003c/h2\u003e\n\u003cp\u003evalue, ok := interfaceVar.(ConcreteType)\u003c/p\u003e\n\u003cp\u003einterfaceVar：一个接口类型的变量\nConcreteType：你期望它实际存储的具体类型（如 int, string, MyStruct 等）\nvalue：如果断言成功，就是该类型的值\nok：布尔值，表示断言是否成功\u003c/p\u003e\n\u003ch2 id=\"二为什么需要类型断言\"\u003e二、为什么需要类型断言？\u003c/h2\u003e\n\u003cp\u003eGo 的接口（interface）可以存储任何类型的值，但当你想使用这个值的具体方法或字段时，就必须知道它的真实类型。\u003c/p\u003e\n\u003cp\u003evar i interface{} = \u0026ldquo;hello\u0026rdquo;\u003c/p\u003e\n\u003cp\u003e// 我知道它是 string，但接口本身不能直接调用 len()\ns := i.(string)  // 类型断言：断言 i 是 string\nfmt.Println(len(s))  // 现在可以了\u003c/p\u003e\n\u003ch2 id=\"三两种写法\"\u003e三、两种写法\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e安全断言（推荐） —— 带 ok 判断\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e\n   s, ok := i.(string)\n   if ok {\n   fmt.Println(\u0026#34;字符串长度:\u0026#34;, len(s))\n   } else {\n   fmt.Println(\u0026#34;i 不是一个字符串\u0026#34;)\n   }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e✅ 优点：不会 panic，适合不确定类型时使用。\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e直接断言 —— 不检查 ok\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e   s := i.(string)  // 如果 i 不是 string，会 panic！\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e⚠️ 风险：如果类型不匹配，程序会崩溃（panic）。\u003c/p\u003e","title":"Type Assertion 类型断言"},{"content":" 看起来很简单，但它其实是 为了内存对齐而存在的。\ntype itab struct { inter *interfacetype // 接口类型信息 _type *_type // 实现接口的具体类型信息 hash uint32 // 类型 hash 值 _ [4]byte fun [1]uintptr // 实现接口方法的函数地址 } 一、Go 的结构体内存布局规则 Go 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。\n规则大致是： 每个字段的起始地址必须是该字段类型的对齐倍数。 比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。 整个结构体的大小必须是其内部最大对齐单位的整数倍。 编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。\n二、itab 的字段分析（以 64 位架构为例） 我们来计算每个字段的内存偏移：\n字段 类型 大小 (Size) 自身对齐值 (Align) 偏移量 (Offset) 备注 inter *interfacetype 8 字节 8 字节 $0 \\rightarrow 8$ 字节 8 字节对齐 _type *_type 8 字节 8 字节 $8 \\rightarrow 16$ 字节 $8$ 是 $8$ 的倍数，已对齐 hash uint32 4 字节 4 字节 $16 \\rightarrow 20$ 字节 $16$ 是 $4$ 的倍数，已对齐 _ [4]byte 4 字节 1 字节 $20 \\rightarrow 24$ 字节 4 字节的填充 (Padding) fun [1]uintptr 8 字节 8 字节 $24 \\rightarrow 32$ 字节 8 字节对齐 $24$ 是 $8$ 的倍数 总大小32 字节，结构体最大对齐是 8 字节，总大小 32 是 8 的倍数。\n三、总结 _ [4]byte 实现对齐的机制这里的关键是： _ [4]byte 本身不实现对齐，它的存在是作为填充（Padding），从而保证其后续字段 fun 的对齐。 1.目标：fun [1]uintptr 字段是一个 uintptr 数组，在 64 位系统上，uintptr 是 8 字节，所以它必须从一个 8 字节对齐的地址开始。 2.计算：\n到 hash 字段结束时，结构体的总大小为 $8 + 8 + 4 = 20$ 字节。 下一个 8 字节对齐的地址是 $24$ ($20$ 之后的第一个 $8$ 的倍数)。 因此，需要在 hash 之后和 fun 之前插入 $24 - 20 = 4$ 字节的填充。 3.实现：Go 源码通过显式地添加一个占位符字段 _ [4]byte 来实现这 4 字节的填充，从而确保 fun [1]uintptr 能够从 24 字节的偏移量开始，完美地实现 8 字节对齐。 ","permalink":"https://MU-GONG-SONG.github.io/blog/posts/memory_alignment/","summary":"\u003cblockquote\u003e\n\u003cp\u003e看起来很简单，但它其实是 为了内存对齐而存在的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003etype itab struct {\n    inter *interfacetype // 接口类型信息\n    _type *_type         // 实现接口的具体类型信息\n    hash  uint32         // 类型 hash 值\n    _     [4]byte\n    fun   [1]uintptr     // 实现接口方法的函数地址\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"一go-的结构体内存布局规则\"\u003e一、Go 的结构体内存布局规则\u003c/h2\u003e\n\u003cp\u003eGo 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。\u003c/p\u003e\n\u003cp\u003e规则大致是：\n每个字段的起始地址必须是该字段类型的对齐倍数。\n比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。\n整个结构体的大小必须是其内部最大对齐单位的整数倍。\n编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。\u003c/p\u003e\n\u003ch2 id=\"二itab-的字段分析以-64-位架构为例\"\u003e二、itab 的字段分析（以 64 位架构为例）\u003c/h2\u003e\n\u003cp\u003e我们来计算每个字段的内存偏移：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: left\"\u003e字段\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e类型\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e大小 (Size)\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e自身对齐值 (Align)\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e偏移量 (Offset)\u003c/th\u003e\n          \u003cth style=\"text-align: left\"\u003e备注\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003einter\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e*interfacetype\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$0 \\rightarrow 8$ 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节对齐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e_type\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e*_type\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$8 \\rightarrow 16$ 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$8$ 是 $8$ 的倍数，已对齐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003ehash\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003euint32\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$16 \\rightarrow 20$ 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$16$ 是 $4$ 的倍数，已对齐\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e_\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e[4]byte\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e4 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e1 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$20 \\rightarrow 24$ 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e4 字节的填充 (Padding)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003efun\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e\u003ccode\u003e[1]uintptr\u003c/code\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e$24 \\rightarrow 32$ 字节\u003c/td\u003e\n          \u003ctd style=\"text-align: left\"\u003e8 字节对齐 $24$ 是 $8$ 的倍数\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e总大小32 字节，结构体最大对齐是 8 字节，总大小 32 是 8 的倍数。\u003c/p\u003e","title":"内存对齐（memory alignment）"},{"content":" 在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\n主键 (Primary Key) 定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。 作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。 特点 唯一性：所有主键值必须唯一，不可重复。 非空性：主键字段禁止为 NULL。 单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。 索引支持：数据库一般会为主键自动创建索引来提高查询效率。\n唯一键 (Unique Key) 定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。 作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。 特点 唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。 多例性：一张表可定义多个唯一键，用来约束不同的业务属性。 索引支持：数据库也通常会为唯一键创建索引，提高检索速度。\n主要区别 数量限制 主键：每张表只能有一个。 唯一键：一张表可以定义多个。\n用途侧重 主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。 唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。\n约束规则 主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。 唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。\n索引与性能 主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。 唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。\n简单示例 主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。 唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。 总结\n主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。\n主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。 相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。 两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。 其次是主键一定不能为空，而唯一键通常允许空值。 还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。 最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。 总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。 ","permalink":"https://MU-GONG-SONG.github.io/blog/posts/key/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在 Go 语言中，类型断言（Type Assertion） 是一种用于从接口值中提取其底层具体类型的操作。它是 Go 实现多态和类型安全的重要机制之一。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"主键-primary-key\"\u003e主键 (Primary Key)\u003c/h2\u003e\n\u003ch5 id=\"定义用于唯一标识表中每一行数据的字段或字段组合是表的核心标识\"\u003e定义：用于唯一标识表中每一行数据的字段或字段组合，是表的核心标识。\u003c/h5\u003e\n\u003ch5 id=\"作用为其他表提供关联引用的核心字段唯一标识表中的每一行数据\"\u003e作用：为其他表提供关联引用的核心字段，唯一标识表中的每一行数据。\u003c/h5\u003e\n\u003ch5 id=\"特点\"\u003e特点\u003c/h5\u003e\n\u003cp\u003e唯一性：所有主键值必须唯一，不可重复。\n非空性：主键字段禁止为 NULL。\n单例性：每张表仅能定义一个主键（但可以是多字段的联合主键）。\n索引支持：数据库一般会为主键自动创建索引来提高查询效率。\u003c/p\u003e\n\u003ch2 id=\"唯一键-unique-key\"\u003e唯一键 (Unique Key)\u003c/h2\u003e\n\u003ch5 id=\"定义用于确保字段或字段组合的值唯一但非表的唯一标识\"\u003e定义：用于确保字段或字段组合的值唯一，但非表的唯一标识。\u003c/h5\u003e\n\u003ch5 id=\"作用提供辅助的唯一性约束便于业务逻辑使用确保指定列或列组合在表中的数据唯一防止重复数据产生\"\u003e作用：提供辅助的唯一性约束，便于业务逻辑使用。确保指定列或列组合在表中的数据唯一，防止重复数据产生。\u003c/h5\u003e\n\u003ch5 id=\"特点-1\"\u003e特点\u003c/h5\u003e\n\u003cp\u003e唯一性：字段值不可重复，但允许 NULL，具体可允许多少个 NULL，取决于数据库实现，如 MySQL 可以有多个。\n多例性：一张表可定义多个唯一键，用来约束不同的业务属性。\n索引支持：数据库也通常会为唯一键创建索引，提高检索速度。\u003c/p\u003e\n\u003ch2 id=\"主要区别\"\u003e主要区别\u003c/h2\u003e\n\u003ch5 id=\"数量限制\"\u003e数量限制\u003c/h5\u003e\n\u003cp\u003e主键：每张表只能有一个。\n唯一键：一张表可以定义多个。\u003c/p\u003e\n\u003ch5 id=\"用途侧重\"\u003e用途侧重\u003c/h5\u003e\n\u003cp\u003e主键：这一列（或列组合）在逻辑上就是记录的“身份证”，最常用来建立实体与实体间的关联。\n唯一键：更多是防止重复数据，保证业务字段（如邮箱、手机号等）具有唯一性，但并非必然用作数据行的主标识。\u003c/p\u003e\n\u003ch5 id=\"约束规则\"\u003e约束规则\u003c/h5\u003e\n\u003cp\u003e主键：强制非空（NOT NULL），插入数据时必须显式指定值，但若设置 AUTO_INCREMENT，MySQL 会自动分配下一个可用值。插入后通常不推荐更新主键值。\n唯一键：允许 NULL 值，例如：MySQL允许多个 NULL视为不冲突而SQL Server仅允许一个 NULL。值可更新，但需保证新值唯一。\u003c/p\u003e\n\u003ch5 id=\"索引与性能\"\u003e索引与性能\u003c/h5\u003e\n\u003cp\u003e主键：默认创建聚集索引（如 MySQL InnoDB 、SQL Server），物理上按主键顺序存储数据，范围查询非常高效。\n唯一键：默认创建非聚集索引，逻辑上维护唯一性，适合等值查询。\u003c/p\u003e\n\u003ch2 id=\"简单示例\"\u003e简单示例\u003c/h2\u003e\n\u003cp\u003e主键场景：在“用户表”中，UserID 作为主键，保证每位用户都能被独一无二地识别和引用。\n唯一键场景：在同一个用户表中，Email 字段也要求不能重复时，就可以为 Email 设置唯一键；此时允许它为 NULL，但实际业务上通常会要求非 NULL 并且唯一。\n总结\u003c/p\u003e\n\u003cp\u003e主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e主键其实就是用来标识每行数据身份的核心字段或字段组合，必须保证主键值的非空性和唯一性。非空性是指插入主键值数据时必须显式指定值，但如果设置了自增（AUTO_INCREMENT），插入数据时就不用手动指定值，数据库会自动分配下一个可用的数值，另外通常不建议在插入后再去修改主键。唯一性是指主键值数据整能够唯一标识表中的一行，此外数据库一般会自动给它创建聚簇索引。\n\n相比之下，唯一键虽然也要保证相应字段的值的唯一性，但它更偏向业务层面的唯一性控制，不一定要当成每行数据的主识别字段。它允许为空，而且在不同的数据库里，对空值的处理也不一样，有的可以插入多个空值，例如MySQL。有的只能插一次，例如SQL Server 。一个表中可以同时存在多个唯一键，每个唯一键都会有对应的非聚簇索引来提升检索效率，这样就能在业务里确保不同属性都能做到唯一。\n\n两者主要区别，首先是每张表只能有一个主键，但可以有多个唯一键。\n\n其次是主键一定不能为空，而唯一键通常允许空值。\n\n还有，主键往往是用来跟别的表建立关联，比如用户表中的 UserID 作为主键，就能让其他表引用这个字段来关联用户信息。唯一键更多是防止个别业务字段的重复，比如用户表中的 Email 地址如果也要求唯一，可以设置成唯一键，这样就能保证任何两个用户都不会用到相同的邮箱。\n\n最后，数据库在主键和唯一键上也有不同的索引方式，InnoDB 或 SQL Server 的主键会采用聚集索引，让物理存储和主键顺序相关联，范围查询时会更高效；而唯一键通常是非聚集索引，比较侧重等值查询。\n\n总之，主键和唯一键都用于保证数据唯一性，但主键更侧重于表的标识和引用，而唯一键更侧重于业务属性的唯一性约束。在实际应用中，通常会结合使用两者来实现数据完整性和业务规则的约束。\n\u003c/code\u003e\u003c/pre\u003e","title":"什么是主键和唯一键？它们的区别是什么？"},{"content":"🚀 什么是 Hugo？ Hugo 是一个基于 Go 语言编写的 静态网站生成器。\n它的最大特点是——速度极快、部署方便、几乎零依赖。\n使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。\n🛠️ 安装 Hugo 在 macOS 上：\nbrew install hugo ","permalink":"https://MU-GONG-SONG.github.io/blog/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","summary":"\u003ch2 id=\"-什么是-hugo\"\u003e🚀 什么是 Hugo？\u003c/h2\u003e\n\u003cp\u003eHugo 是一个基于 Go 语言编写的 \u003cstrong\u003e静态网站生成器\u003c/strong\u003e。\u003cbr\u003e\n它的最大特点是——\u003cstrong\u003e速度极快、部署方便、几乎零依赖\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"-安装-hugo\"\u003e🛠️ 安装 Hugo\u003c/h2\u003e\n\u003cp\u003e在 macOS 上：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebrew install hugo\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"初识 Hugo：打造你的静态博客"},{"content":" 👋 简介 你好！我是 你的名字，一名热爱技术与写作的创作者。\n这里记录我的学习笔记、项目、随笔与资源分享。\n我热衷于探索高效开发、开源工具和知识体系构建。\n⚡️ 速览 职业：软件工程师 / 前端 / 后端（根据实际修改） 所在地：城市，国家 擅长：Go、Docker、Kubernetes、Hugo 邮箱：you@example.com（请替换） 🧭 详细介绍 我喜欢把复杂的问题拆解成可执行的小步骤——这同样适用于代码和生活。\n我的博客主要分享：实践记录、问题复现与解决方案、工具推荐与配置教程。\n如果你是初学者，欢迎从我的标签页（如 #入门）开始；\n如果你是同行，也欢迎与我交流合作。\n🚀 项目与成果 项目 A — GitHub 链接：简短说明 项目 B — GitHub 链接：简短说明 （你可以在这里列出想展示的作品或文章）\n📫 联系我 📧 邮箱：you@example.com 🐙 GitHub：yourusername 🐦 Twitter：yourhandle 🌅 座右铭 悟已往之不谏，知来者之可追。\n—— 陶渊明《归去来兮辞》\n","permalink":"https://MU-GONG-SONG.github.io/blog/about/","summary":"关于我的简单介绍、联系方式和创作理念。","title":"About — 关于我"},{"content":"今天开始记录我在 Go 高并发项目中的一些心得体会。\n","permalink":"https://MU-GONG-SONG.github.io/blog/posts/fist-blog/","summary":"\u003cp\u003e今天开始记录我在 Go 高并发项目中的一些心得体会。\u003c/p\u003e","title":"我的第一篇博客"}]