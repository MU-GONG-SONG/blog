---
title: "内存对齐（memory alignment）"
date: 2025-10-14
categories: ["内存"]
tags: ["memory"]
draft: false
---


> 看起来很简单，但它其实是 为了内存对齐而存在的。


`````
type itab struct {
    inter *interfacetype // 接口类型信息
    _type *_type         // 实现接口的具体类型信息
    hash  uint32         // 类型 hash 值
    _     [4]byte
    fun   [1]uintptr     // 实现接口方法的函数地址
}
`````
## 一、Go 的结构体内存布局规则
Go 里每个字段在内存中都有一个偏移量（offset），而编译器会自动插入 padding（填充字节），以保证每个字段都按其类型对齐（alignment）。

规则大致是：
每个字段的起始地址必须是该字段类型的对齐倍数。
比如：uint32 对齐要求 4 字节，uintptr（在 64 位机上）对齐要求 8 字节。
整个结构体的大小必须是其内部最大对齐单位的整数倍。
编译器自动插入 padding 字节，但有时源码里会显式加 _ [N]byte 来占位或兼容 ABI。

## 二、itab 的字段分析（以 64 位架构为例）
我们来计算每个字段的内存偏移：

[//]: # (![内存偏移]&#40;.memory_alignment_images/内存对齐.png&#41;)


| 字段 | 类型 | 大小 (Size) | 自身对齐值 (Align) | 偏移量 (Offset)<br/>单位:字节 | 备注                           |
| :--- | :--- | :--- | :--- |:-----------------------|:-----------------------------|
| `inter` | `*interfacetype` | 8 字节 | 8 字节 | 0 → 8                  | 8 字节对齐                       |
| `_type` | `*_type` | 8 字节 | 8 字节 | 8→16                   |  8  是  8  的倍数，已对齐            |
| `hash` | `uint32` | 4 字节 | 4 字节 | 16→20                  |  16  是  4  的倍数，已对齐           |
| `_` | `[4]byte` | 4 字节 | 1 字节 | 20→24                  | 4 字节的填充 (Padding)            |
| `fun` | `[1]uintptr` | 8 字节 | 8 字节 | 24→32                  | 8 字节对齐  24  是  8  的倍数        |

总大小32 字节，结构体最大对齐是 8 字节，总大小 32 是 8 的倍数。
## 三、总结

_ [4]byte 实现对齐的机制这里的关键是：
_ [4]byte 本身不实现对齐，它的存在是作为填充（Padding），从而保证其后续字段 fun 的对齐。
1.目标：fun [1]uintptr 字段是一个 uintptr 数组，在 64 位系统上，uintptr 是 8 字节，所以它必须从一个 8 字节对齐的地址开始。
2.计算：
 * 到 hash 字段结束时，结构体的总大小为  8 + 8 + 4 = 20  字节。
 * 下一个 8 字节对齐的地址是  24  ( 20  之后的第一个  8  的倍数)。
 * 因此，需要在 hash 之后和 fun 之前插入  24 - 20 = 4  字节的填充。
3.实现：Go 源码通过显式地添加一个占位符字段 _ [4]byte 来实现这 4 字节的填充，从而确保 fun [1]uintptr 能够从 24 字节的偏移量开始，完美地实现 8 字节对齐。
