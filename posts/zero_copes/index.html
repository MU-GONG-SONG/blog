<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>什么是零拷贝? | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content="Kafka"><meta name=description content="
零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。

1.核心原理 ？
在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）：
第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。
第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。
第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。
第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。
零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。
2.常见的零拷贝实现方式
2.1 sendfile
这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。
实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。
消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。
2.2 内存映射文件 (mmap)
内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。
实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。
消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。
3.零拷贝的优势
降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。
减少延迟： 数据传输路径更短。
提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。
"><meta name=author content="Mumu"><link rel=canonical href=https://mugong-song.github.io/blog/posts/zero_copes/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://mugong-song.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mugong-song.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mugong-song.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://mugong-song.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://mugong-song.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://mugong-song.github.io/blog/posts/zero_copes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://mugong-song.github.io/blog/posts/zero_copes/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="什么是零拷贝?"><meta property="og:description" content=" 零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。
1.核心原理 ？ 在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）： 第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。 第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。 第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。 第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。 零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。
2.常见的零拷贝实现方式 2.1 sendfile 这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。 实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。 消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。 2.2 内存映射文件 (mmap) 内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。 实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。 消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。 3.零拷贝的优势 降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。 减少延迟： 数据传输路径更短。 提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。 "><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-10-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-10-14T00:00:00+00:00"><meta property="article:tag" content="Kafka"><meta name=twitter:card content="summary"><meta name=twitter:title content="什么是零拷贝?"><meta name=twitter:description content="
零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。

1.核心原理 ？
在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）：
第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。
第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。
第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。
第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。
零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。
2.常见的零拷贝实现方式
2.1 sendfile
这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。
实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。
消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。
2.2 内存映射文件 (mmap)
内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。
实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。
消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。
3.零拷贝的优势
降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。
减少延迟： 数据传输路径更短。
提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mugong-song.github.io/blog/posts/"},{"@type":"ListItem","position":2,"name":"什么是零拷贝?","item":"https://mugong-song.github.io/blog/posts/zero_copes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"什么是零拷贝?","name":"什么是零拷贝?","description":" 零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。\n1.核心原理 ？ 在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）： 第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。 第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。 第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。 第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。 零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。\n2.常见的零拷贝实现方式 2.1 sendfile 这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。 实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。 消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。 2.2 内存映射文件 (mmap) 内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。 实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。 消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。 3.零拷贝的优势 降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。 减少延迟： 数据传输路径更短。 提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。 ","keywords":["Kafka"],"articleBody":" 零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。\n1.核心原理 ？ 在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）： 第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。 第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。 第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。 第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。 零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。\n2.常见的零拷贝实现方式 2.1 sendfile 这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。 实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。 消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。 2.2 内存映射文件 (mmap) 内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。 实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。 消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。 3.零拷贝的优势 降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。 减少延迟： 数据传输路径更短。 提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。 ","wordCount":"79","inLanguage":"zh","datePublished":"2025-10-14T00:00:00Z","dateModified":"2025-10-14T00:00:00Z","author":{"@type":"Person","name":"Mumu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mugong-song.github.io/blog/posts/zero_copes/"},"publisher":{"@type":"Organization","name":"Q-song | 技术.生活.阅读.思考","logo":{"@type":"ImageObject","url":"https://mugong-song.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mugong-song.github.io/blog/ accesskey=h title="Q-song (Alt + H)"><img src=https://mugong-song.github.io/blog/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mugong-song.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://mugong-song.github.io/blog/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://mugong-song.github.io/blog/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://mugong-song.github.io/blog/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://mugong-song.github.io/blog/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">什么是零拷贝?</h1><div class=post-meta><span title='2025-10-14 00:00:00 +0000 UTC'>2025年10月14日</span>&nbsp;·&nbsp;<span>Mumu</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#1%e6%a0%b8%e5%bf%83%e5%8e%9f%e7%90%86- aria-label="1.核心原理 ？">1.核心原理 ？</a></li><li><a href=#2%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9b%b6%e6%8b%b7%e8%b4%9d%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f aria-label=2.常见的零拷贝实现方式>2.常见的零拷贝实现方式</a><ul><li><a href=#21-sendfile aria-label="2.1 sendfile">2.1 sendfile</a></li><li><a href=#22-%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6-mmap aria-label="2.2 内存映射文件 (mmap)">2.2 内存映射文件 (mmap)</a></li></ul></li><li><a href=#3%e9%9b%b6%e6%8b%b7%e8%b4%9d%e7%9a%84%e4%bc%98%e5%8a%bf aria-label=3.零拷贝的优势>3.零拷贝的优势</a></li></ul></div></details></div><div class=post-content><blockquote><p>零拷贝（Zero-Copy）是一种计算机操作技术，主要应用于高性能网络和文件 I/O 领域。它的核心目标是减少 CPU 在传输数据时进行不必要的内存数据拷贝，以及减少用户空间和内核空间之间的上下文切换次数。</p></blockquote><h3 id=1核心原理->1.核心原理 ？<a hidden class=anchor aria-hidden=true href=#1核心原理->#</a></h3><pre tabindex=0><code>在传统的 I/O 操作中，数据通常需要经历四次拷贝才能完成传输（例如将文件通过网络发送给客户端）：
第一次拷贝： 数据从磁盘读取到操作系统内核的缓冲区（通常是 Page Cache）。
第二次拷贝： 数据从内核缓冲区拷贝到应用程序的用户缓冲区。
第三次拷贝： 数据从用户缓冲区拷贝回内核的 Socket 缓冲区。
第四次拷贝： 数据从 Socket 缓冲区拷贝到网络接口卡（NIC）的缓冲区，最终发送。
</code></pre><p><strong>零拷贝技术通过特定的系统调用和硬件支持，消除了步骤 2 和 3 的 CPU 拷贝。</strong></p><h3 id=2常见的零拷贝实现方式>2.常见的零拷贝实现方式<a hidden class=anchor aria-hidden=true href=#2常见的零拷贝实现方式>#</a></h3><h4 id=21-sendfile>2.1 sendfile<a hidden class=anchor aria-hidden=true href=#21-sendfile>#</a></h4><pre tabindex=0><code>这是最常见的零拷贝实现，例如 Apache Kafka 和 Nginx 等 Web 服务器广泛使用它来高效传输文件数据。
实现机制： 它将数据从一个文件描述符直接传输到另一个文件描述符（例如从磁盘文件 FD 到网络 Socket FD）。
消除拷贝： sendfile 允许数据在内核缓冲区和 Socket 缓冲区之间直接传输，跳过了用户缓冲区，从而消除了两次 CPU 拷贝。
</code></pre><h4 id=22-内存映射文件-mmap>2.2 内存映射文件 (mmap)<a hidden class=anchor aria-hidden=true href=#22-内存映射文件-mmap>#</a></h4><pre tabindex=0><code>内存映射文件技术通过 mmap 系统调用将文件内容直接映射到进程的虚拟地址空间。
实现： 应用程序通过指针直接读写映射的内存地址，而这个地址对应的物理内存正是内核缓冲区。
消除拷贝： 它消除了数据从内核缓冲区拷贝到用户缓冲区的步骤，因为内核缓冲区和用户空间共享了同一块物理内存。
</code></pre><h3 id=3零拷贝的优势>3.零拷贝的优势<a hidden class=anchor aria-hidden=true href=#3零拷贝的优势>#</a></h3><pre tabindex=0><code>降低 CPU 开销： 减少了 CPU 进行数据拷贝的工作量。
减少延迟： 数据传输路径更短。
提高吞吐量： 特别适用于高并发、I/O 密集型的场景，如文件服务器、Web 服务器和消息中间件（如 Kafka）。
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://mugong-song.github.io/blog/tags/kafka/>Kafka</a></li></ul><nav class=paginav><a class=prev href=https://mugong-song.github.io/blog/posts/lock/><span class=title>« 上一页</span><br><span>什么是“重锁” Heavy Lock?</span>
</a><a class=next href=https://mugong-song.github.io/blog/posts/garbage-collection/><span class=title>下一页 »</span><br><span>垃圾回收机制 Garbage Collection</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://mugong-song.github.io/blog/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>