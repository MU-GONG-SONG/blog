<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Q-song | 技术.生活.阅读.思考</title><meta name=keywords content><meta name=description content="Posts - Q-song | 技术.生活.阅读.思考"><meta name=author content="Mumu"><link rel=canonical href=https://mugong-song.github.io/blog/posts/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=https://mugong-song.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mugong-song.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mugong-song.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://mugong-song.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://mugong-song.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://mugong-song.github.io/blog/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MZJS5SGFET"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MZJS5SGFET")}</script><meta property="og:url" content="https://mugong-song.github.io/blog/posts/"><meta property="og:site_name" content="Q-song | 技术.生活.阅读.思考"><meta property="og:title" content="Posts"><meta property="og:description" content="个人博客"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content="个人博客"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mugong-song.github.io/blog/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mugong-song.github.io/blog/ accesskey=h title="Q-song (Alt + H)"><img src=https://mugong-song.github.io/blog/img/%E8%B6%B3%E8%BF%B9.png alt aria-label=logo height=35>Q-song</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mugong-song.github.io/blog/search/ title="🔎 搜索"><span>🔎 搜索</span></a></li><li><a href=https://mugong-song.github.io/blog/archives title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://mugong-song.github.io/blog/categories/ title="⛩️ 分类"><span>⛩️ 分类</span></a></li><li><a href=https://mugong-song.github.io/blog/tags/ title="🧩 标签"><span>🧩 标签</span></a></li><li><a href=https://mugong-song.github.io/blog/about title="🙋🏻‍♂️ 关于"><span>🙋🏻‍♂️ 关于</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Go sheduler 是什么?</h2></header><div class=entry-content><p>Go sheduler是什么? Go 程序的执行有两个层面：Go Program 和 Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutine 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。
Go scheduler 可以说是 Go 运行时的一个最重要的 部分了。 Runtime 维护所有的 goroutine ，并通过 scheduler 来进行调度。goroutine 和 threads 是独立的， 但是 goroutine 要依赖 threads 才能执行。 Go 程序执行的高效和 scheduler 的调度是分不开的。 实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutine 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面，操作系统并不能感知到 goroutine 的存在。
G、M、P三个基础的结构体来实现 goroutine 的调度： G 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。 M 表示内核线程，包含正在运行的 goroutine 等字段。 P 代表一个虚拟的CPU Processor，它维护一个处于 Runnable 状态的 goroutine 队列，M 需要获得 P 才能运行 G。 当然还有一个核心的结构体：sched，它总揽全局，维持整个调度器的运行。 Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一 个 M 用来开始 G 的运行。随着时间的推移，G和M的创建数量逐渐增多。 在 Go 的早期版本，并没有 P 这个结构体，M 必须从一个全局的队列里获取要运行的 G，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来调度器在 Dmitry Vyukov (Go 语言运行时 runtime 和调度器的核心贡献者之一) ，加 上了 P 结构体。每个 P 维护一个处于 Runnable 状态的 G 的队列，解决了原来的全局锁问题。
...</p></div><footer class=entry-footer><span title='2025-10-13 00:00:00 +0000 UTC'>2025年10月13日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to Go sheduler 是什么?" href=https://mugong-song.github.io/blog/posts/gmp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>slice 和 数组</h2></header><div class=entry-content><p>Go 语言里 slice 和 map 是非常有用的两个内置数据结构， 线上的工程代码几乎不可能绕开它们。
1.数组与切片 因为切片（slice）比数组更好用，也更安全，Go 推荐使用 slice 而不是数组。本节内容比较 了 slice 和数组的区别，也研究了 slice 的一些特有的性质。
1.1数组和切片有何异同 Go 语言中的切片（slice）结构的本质是对数组的封装，它描述一个数组的片段。无论是数组 还是切片，都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更改。在 Go 语言中，数组是不常见的，因为其长度 是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。而切片则非常灵 活，它可以动态地扩容，且切片的类型和长度无关。
func main() { arr1 := [1]int{1} arr2 := [2]int{1, 2} if arr1 == arr2 { fmt.Println("equal type") } } 尝试运行，报编译错误：
./test.go:16:10: invalid operation: arr1 == arr2 (mismatched types [1]int and [2]int) 因为两个数组的长度不同，根本就不是同一类型，因此不能进行比较。 数组是一片连续的内存，切片实际上是一个结构体，包含三个字段：长度、容量、底层数组。
// src/runtime/slice.go type slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量 } 注意，底层数组可以被多个切片同时指向，因此对一个切 片的元素进行操作有可能会影响到其他切片。
...</p></div><footer class=entry-footer><span title='2025-10-13 00:00:00 +0000 UTC'>2025年10月13日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to slice 和 数组" href=https://mugong-song.github.io/blog/posts/slice_01/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SQL_Index 索引</h2></header><div class=entry-content><p>在 Go 后端开发中，我们通常使用 MySQL 或 PostgreSQL 等关系型数据库，索引设计的好坏直接决定了服务接口的响应速度。
1.索引设计 1.1 选择合适的列作为索引： 选择性高（High Selectivity）： 索引列的不重复值越多越好。例如，用户 ID（唯一）比性别（只有两三种值）更适合作为索引。 场景： 在设计用户服务时，user_id、email 等是理想的索引列。 常用作查询条件（Where）： 经常出现在 WHERE 子句中的列，或者用于连接（JOIN）的列。 排序/分组（Order By/Group By）： 经常用于排序或分组的列。 1.2 考虑联合索引（Composite Index）： 最左前缀原则 (Leftmost Prefix Principle)： 这是联合索引设计的核心。如果创建了 (A, B, C) 的联合索引，它可以用于查询 WHERE A = ?、WHERE A = ? AND B = ?、WHERE A = ? AND B = ? AND C = ?，但不能单独用于 WHERE B = ? 或 WHERE C = ?。 场景： 在设计订单查询接口时，如果经常查询 WHERE user_id = ? AND order_status = ?，应建立 (user_id, order_status) 的联合索引。 1.3 覆盖索引 (Covering Index)： 如果查询的所有字段都包含在索引中，那么数据库不需要回表（查找主键对应的数据行），直接从索引中返回数据即可。这能大幅提升性能。 场景： 当你需要查询某个用户的订单状态和创建时间，只创建 (user_id, status, create_time) 的联合索引。查询语句为 SELECT status, create_time FROM orders WHERE user_id = ?，数据库直接通过索引就能拿到结果。 1.4 索引数量的平衡： 索引不是越多越好。每个索引都会占用磁盘空间，并且在进行 INSERT, UPDATE, DELETE 操作时，数据库需要维护索引，造成写操作性能下降。 场景： 在设计高写入量的日志表或消息表时，应尽量少建索引，只保留用于最核心查询的索引。 2.高效命中策略 使用 Explain ： 在 Go 后端进行复杂查询优化时，一定要在测试环境使用 EXPLAIN 命令分析 SQL 语句，确保 type 列不是 ALL（全表扫描），key 列使用了正确的索引。
...</p></div><footer class=entry-footer><span title='2025-10-13 00:00:00 +0000 UTC'>2025年10月13日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to SQL_Index 索引" href=https://mugong-song.github.io/blog/posts/sql_index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>First Encounter with Hugo</h2></header><div class=entry-content><p>🚀 什么是 Hugo？ Hugo 是一个基于 Go 语言编写的 静态网站生成器。
它的最大特点是——速度极快、部署方便、几乎零依赖。
使用 Hugo，你可以用 Markdown 写文章，然后自动生成一个完整的博客网站。
🛠️ 安装 Hugo 在 macOS 上：
brew install hugo</p></div><footer class=entry-footer><span title='2025-10-12 15:30:00 +0800 +0800'>2025年10月12日</span>&nbsp;·&nbsp;<span>Beeta</span></footer><a class=entry-link aria-label="post link to First Encounter with Hugo" href=https://mugong-song.github.io/blog/posts/%E5%88%9D%E8%AF%86-hugo%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>垃圾回收机制 Garbage Collection</h2></header><div class=entry-content><p>1.垃圾回收的认识 1.1垃圾回收是什么，有什么作用 GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。 当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请 时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。而 负责垃圾回收的程序组件，即为垃圾回收器。 垃圾回收其实是一个完美的“Simplicity is Complicated”的例子。一方面，程序员受益于 GC，也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留的内存。另一 方面，GC 对程序员几乎不可见，仅在程序需要进行特殊优化时，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控的时候才得以现身。 通常，垃圾回收器的执行过程被划分为两个半独立的组件：
1）赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户 态的代码仅仅只修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上 进行操作。 2）回收器（Collector）：负责执行垃圾回收的代码。
1.2常见的垃圾回收的实现方式有哪些，Go使用的是什么 所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这 两种形式的混合运用。
（1）追踪式 GC 从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的 对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。 （2）引用计数式 GC 每个对象自身包含一个被引用的计数器，当计数器归零时自动得到回收。因为此方法缺陷较 多，在追求高性能时通常不被应用。Python、Objective-C 等均为引用计数式 GC。 比较常见的 GC 实现方式包括：
1）追踪式，分为多种不同类型，例如： 标记清扫：从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。 标记整理：为了解决内存碎片问题而提出，在标记过程中，将对象尽可能整理到一块连续的内 存上。 2)增量式：将标记与清扫的过程分批执行，每次执行很小的部分，从而增量推进垃圾回收，达到 近似实时、几乎无停顿的效果。 3)增量整理：在增量式的基础上，增加对对象的整理过程。 4)分代式：将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于 某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不 长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。</p></div><footer class=entry-footer><span title='2025-10-12 00:00:00 +0000 UTC'>2025年10月12日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 垃圾回收机制 Garbage Collection" href=https://mugong-song.github.io/blog/posts/garbage-collection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我的第一篇博客</h2></header><div class=entry-content><p>今天开始记录我在 Go 高并发项目中的一些心得体会。</p></div><footer class=entry-footer><span title='2025-10-12 00:00:00 +0000 UTC'>2025年10月12日</span>&nbsp;·&nbsp;<span>Mumu</span></footer><a class=entry-link aria-label="post link to 我的第一篇博客" href=https://mugong-song.github.io/blog/posts/fist-blog/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://mugong-song.github.io/blog/posts/>«&nbsp;上一页&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://mugong-song.github.io/blog/>Q-song | 技术.生活.阅读.思考</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>